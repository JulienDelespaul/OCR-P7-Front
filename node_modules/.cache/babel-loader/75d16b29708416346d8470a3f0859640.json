{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n\n  return to;\n};\n\nimport { isBigint, isDate, isInfinite, isMap, isNaNValue, isRegExp, isSet, isUndefined, isSymbol, isArray, isError, isTypedArray, isURL } from './is';\nimport { ClassRegistry } from './class-registry';\nimport { SymbolRegistry } from './symbol-registry';\nimport { CustomTransformerRegistry } from './custom-transformer-registry';\nimport { allowedErrorProps } from './error-props';\nimport { findArr } from './util';\n\nfunction simpleTransformation(isApplicable, annotation, transform, untransform) {\n  return {\n    isApplicable: isApplicable,\n    annotation: annotation,\n    transform: transform,\n    untransform: untransform\n  };\n}\n\nvar simpleRules = [simpleTransformation(isUndefined, 'undefined', function () {\n  return null;\n}, function () {\n  return undefined;\n}), simpleTransformation(isBigint, 'bigint', function (v) {\n  return v.toString();\n}, function (v) {\n  if (typeof BigInt !== 'undefined') {\n    return BigInt(v);\n  }\n\n  console.error('Please add a BigInt polyfill.');\n  return v;\n}), simpleTransformation(isDate, 'Date', function (v) {\n  return v.toISOString();\n}, function (v) {\n  return new Date(v);\n}), simpleTransformation(isError, 'Error', function (v) {\n  var baseError = {\n    name: v.name,\n    message: v.message\n  };\n  allowedErrorProps.forEach(function (prop) {\n    baseError[prop] = v[prop];\n  });\n  return baseError;\n}, function (v) {\n  var e = new Error(v.message);\n  e.name = v.name;\n  e.stack = v.stack;\n  allowedErrorProps.forEach(function (prop) {\n    e[prop] = v[prop];\n  });\n  return e;\n}), simpleTransformation(isRegExp, 'regexp', function (v) {\n  return '' + v;\n}, function (regex) {\n  var body = regex.slice(1, regex.lastIndexOf('/'));\n  var flags = regex.slice(regex.lastIndexOf('/') + 1);\n  return new RegExp(body, flags);\n}), simpleTransformation(isSet, 'set', // (sets only exist in es6+)\n// eslint-disable-next-line es5/no-es6-methods\nfunction (v) {\n  return __spreadArray([], __read(v.values()));\n}, function (v) {\n  return new Set(v);\n}), simpleTransformation(isMap, 'map', function (v) {\n  return __spreadArray([], __read(v.entries()));\n}, function (v) {\n  return new Map(v);\n}), simpleTransformation(function (v) {\n  return isNaNValue(v) || isInfinite(v);\n}, 'number', function (v) {\n  if (isNaNValue(v)) {\n    return 'NaN';\n  }\n\n  if (v > 0) {\n    return 'Infinity';\n  } else {\n    return '-Infinity';\n  }\n}, Number), simpleTransformation(function (v) {\n  return v === 0 && 1 / v === -Infinity;\n}, 'number', function () {\n  return '-0';\n}, Number), simpleTransformation(isURL, 'URL', function (v) {\n  return v.toString();\n}, function (v) {\n  return new URL(v);\n})];\n\nfunction compositeTransformation(isApplicable, annotation, transform, untransform) {\n  return {\n    isApplicable: isApplicable,\n    annotation: annotation,\n    transform: transform,\n    untransform: untransform\n  };\n}\n\nvar symbolRule = compositeTransformation(function (s) {\n  if (isSymbol(s)) {\n    var isRegistered = !!SymbolRegistry.getIdentifier(s);\n    return isRegistered;\n  }\n\n  return false;\n}, function (s) {\n  var identifier = SymbolRegistry.getIdentifier(s);\n  return ['symbol', identifier];\n}, function (v) {\n  return v.description;\n}, function (_, a) {\n  var value = SymbolRegistry.getValue(a[1]);\n\n  if (!value) {\n    throw new Error('Trying to deserialize unknown symbol');\n  }\n\n  return value;\n});\nvar constructorToName = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array, Uint8ClampedArray].reduce(function (obj, ctor) {\n  obj[ctor.name] = ctor;\n  return obj;\n}, {});\nvar typedArrayRule = compositeTransformation(isTypedArray, function (v) {\n  return ['typed-array', v.constructor.name];\n}, function (v) {\n  return __spreadArray([], __read(v));\n}, function (v, a) {\n  var ctor = constructorToName[a[1]];\n\n  if (!ctor) {\n    throw new Error('Trying to deserialize unknown typed array');\n  }\n\n  return new ctor(v);\n});\nexport function isInstanceOfRegisteredClass(potentialClass) {\n  if (potentialClass === null || potentialClass === void 0 ? void 0 : potentialClass.constructor) {\n    var isRegistered = !!ClassRegistry.getIdentifier(potentialClass.constructor);\n    return isRegistered;\n  }\n\n  return false;\n}\nvar classRule = compositeTransformation(isInstanceOfRegisteredClass, function (clazz) {\n  var identifier = ClassRegistry.getIdentifier(clazz.constructor);\n  return ['class', identifier];\n}, function (clazz) {\n  var allowedProps = ClassRegistry.getAllowedProps(clazz.constructor);\n\n  if (!allowedProps) {\n    return __assign({}, clazz);\n  }\n\n  var result = {};\n  allowedProps.forEach(function (prop) {\n    result[prop] = clazz[prop];\n  });\n  return result;\n}, function (v, a) {\n  var clazz = ClassRegistry.getValue(a[1]);\n\n  if (!clazz) {\n    throw new Error('Trying to deserialize unknown class - check https://github.com/blitz-js/superjson/issues/116#issuecomment-773996564');\n  }\n\n  return Object.assign(Object.create(clazz.prototype), v);\n});\nvar customRule = compositeTransformation(function (value) {\n  return !!CustomTransformerRegistry.findApplicable(value);\n}, function (value) {\n  var transformer = CustomTransformerRegistry.findApplicable(value);\n  return ['custom', transformer.name];\n}, function (value) {\n  var transformer = CustomTransformerRegistry.findApplicable(value);\n  return transformer.serialize(value);\n}, function (v, a) {\n  var transformer = CustomTransformerRegistry.findByName(a[1]);\n\n  if (!transformer) {\n    throw new Error('Trying to deserialize unknown custom value');\n  }\n\n  return transformer.deserialize(v);\n});\nvar compositeRules = [classRule, symbolRule, customRule, typedArrayRule];\nexport var transformValue = function (value) {\n  var applicableCompositeRule = findArr(compositeRules, function (rule) {\n    return rule.isApplicable(value);\n  });\n\n  if (applicableCompositeRule) {\n    return {\n      value: applicableCompositeRule.transform(value),\n      type: applicableCompositeRule.annotation(value)\n    };\n  }\n\n  var applicableSimpleRule = findArr(simpleRules, function (rule) {\n    return rule.isApplicable(value);\n  });\n\n  if (applicableSimpleRule) {\n    return {\n      value: applicableSimpleRule.transform(value),\n      type: applicableSimpleRule.annotation\n    };\n  }\n\n  return undefined;\n};\nvar simpleRulesByAnnotation = {};\nsimpleRules.forEach(function (rule) {\n  simpleRulesByAnnotation[rule.annotation] = rule;\n});\nexport var untransformValue = function (json, type) {\n  if (isArray(type)) {\n    switch (type[0]) {\n      case 'symbol':\n        return symbolRule.untransform(json, type);\n\n      case 'class':\n        return classRule.untransform(json, type);\n\n      case 'custom':\n        return customRule.untransform(json, type);\n\n      case 'typed-array':\n        return typedArrayRule.untransform(json, type);\n\n      default:\n        throw new Error('Unknown transformation: ' + type);\n    }\n  } else {\n    var transformation = simpleRulesByAnnotation[type];\n\n    if (!transformation) {\n      throw new Error('Unknown transformation: ' + type);\n    }\n\n    return transformation.untransform(json);\n  }\n};","map":{"version":3,"mappings":"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","names":["isBigint","isDate","isInfinite","isMap","isNaNValue","isRegExp","isSet","isUndefined","isSymbol","isArray","isError","isTypedArray","isURL","ClassRegistry","SymbolRegistry","CustomTransformerRegistry","allowedErrorProps","findArr","simpleTransformation","isApplicable","annotation","transform","untransform","simpleRules","toString","BigInt","v","console","error","toISOString","Date","baseError","name","message","forEach","prop","e","Error","stack","body","regex","slice","lastIndexOf","flags","RegExp","values","Set","entries","Map","Number","Infinity","URL","compositeTransformation","symbolRule","s","isRegistered","getIdentifier","identifier","description","_","a","value","getValue","constructorToName","Int8Array","Uint8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","Uint8ClampedArray","reduce","obj","ctor","typedArrayRule","constructor","isInstanceOfRegisteredClass","potentialClass","classRule","clazz","allowedProps","getAllowedProps","result","Object","assign","create","prototype","customRule","findApplicable","transformer","serialize","findByName","deserialize","compositeRules","transformValue","applicableCompositeRule","type","applicableSimpleRule","undefined","simpleRulesByAnnotation","rule","untransformValue","json","transformation"],"sources":["/home/julien/Bureau/P7 Front/OCR-P7-Front/node_modules/superjson/src/transformer.ts"],"sourcesContent":["import {\n  isBigint,\n  isDate,\n  isInfinite,\n  isMap,\n  isNaNValue,\n  isRegExp,\n  isSet,\n  isUndefined,\n  isSymbol,\n  isArray,\n  isError,\n  isTypedArray,\n  TypedArrayConstructor,\n  isURL,\n} from './is';\nimport { ClassRegistry } from './class-registry';\nimport { SymbolRegistry } from './symbol-registry';\nimport { CustomTransformerRegistry } from './custom-transformer-registry';\nimport { allowedErrorProps } from './error-props';\nimport { findArr } from './util';\n\nexport type PrimitiveTypeAnnotation = 'number' | 'undefined' | 'bigint';\n\ntype LeafTypeAnnotation =\n  | PrimitiveTypeAnnotation\n  | 'regexp'\n  | 'Date'\n  | 'Error'\n  | 'URL';\n\ntype TypedArrayAnnotation = ['typed-array', string];\ntype ClassTypeAnnotation = ['class', string];\ntype SymbolTypeAnnotation = ['symbol', string];\ntype CustomTypeAnnotation = ['custom', string];\n\ntype SimpleTypeAnnotation = LeafTypeAnnotation | 'map' | 'set';\n\ntype CompositeTypeAnnotation =\n  | TypedArrayAnnotation\n  | ClassTypeAnnotation\n  | SymbolTypeAnnotation\n  | CustomTypeAnnotation;\n\nexport type TypeAnnotation = SimpleTypeAnnotation | CompositeTypeAnnotation;\n\nfunction simpleTransformation<I, O, A extends SimpleTypeAnnotation>(\n  isApplicable: (v: any) => v is I,\n  annotation: A,\n  transform: (v: I) => O,\n  untransform: (v: O) => I\n) {\n  return {\n    isApplicable,\n    annotation,\n    transform,\n    untransform,\n  };\n}\n\nconst simpleRules = [\n  simpleTransformation(\n    isUndefined,\n    'undefined',\n    () => null,\n    () => undefined\n  ),\n  simpleTransformation(\n    isBigint,\n    'bigint',\n    v => v.toString(),\n    v => {\n      if (typeof BigInt !== 'undefined') {\n        return BigInt(v);\n      }\n\n      console.error('Please add a BigInt polyfill.');\n\n      return v as any;\n    }\n  ),\n  simpleTransformation(\n    isDate,\n    'Date',\n    v => v.toISOString(),\n    v => new Date(v)\n  ),\n\n  simpleTransformation(\n    isError,\n    'Error',\n    v => {\n      const baseError: any = {\n        name: v.name,\n        message: v.message,\n      };\n\n      allowedErrorProps.forEach(prop => {\n        baseError[prop] = (v as any)[prop];\n      });\n\n      return baseError;\n    },\n    v => {\n      const e = new Error(v.message);\n      e.name = v.name;\n      e.stack = v.stack;\n\n      allowedErrorProps.forEach(prop => {\n        (e as any)[prop] = v[prop];\n      });\n\n      return e;\n    }\n  ),\n\n  simpleTransformation(\n    isRegExp,\n    'regexp',\n    v => '' + v,\n    regex => {\n      const body = regex.slice(1, regex.lastIndexOf('/'));\n      const flags = regex.slice(regex.lastIndexOf('/') + 1);\n      return new RegExp(body, flags);\n    }\n  ),\n\n  simpleTransformation(\n    isSet,\n    'set',\n    // (sets only exist in es6+)\n    // eslint-disable-next-line es5/no-es6-methods\n    v => [...v.values()],\n    v => new Set(v)\n  ),\n  simpleTransformation(\n    isMap,\n    'map',\n    v => [...v.entries()],\n    v => new Map(v)\n  ),\n\n  simpleTransformation<number, 'NaN' | 'Infinity' | '-Infinity', 'number'>(\n    (v): v is number => isNaNValue(v) || isInfinite(v),\n    'number',\n    v => {\n      if (isNaNValue(v)) {\n        return 'NaN';\n      }\n\n      if (v > 0) {\n        return 'Infinity';\n      } else {\n        return '-Infinity';\n      }\n    },\n    Number\n  ),\n\n  simpleTransformation<number, '-0', 'number'>(\n    (v): v is number => v === 0 && 1 / v === -Infinity,\n    'number',\n    () => {\n      return '-0';\n    },\n    Number\n  ),\n\n  simpleTransformation(\n    isURL,\n    'URL',\n    v => v.toString(),\n    v => new URL(v)\n  ),\n];\n\nfunction compositeTransformation<I, O, A extends CompositeTypeAnnotation>(\n  isApplicable: (v: any) => v is I,\n  annotation: (v: I) => A,\n  transform: (v: I) => O,\n  untransform: (v: O, a: A) => I\n) {\n  return {\n    isApplicable,\n    annotation,\n    transform,\n    untransform,\n  };\n}\n\nconst symbolRule = compositeTransformation(\n  (s): s is Symbol => {\n    if (isSymbol(s)) {\n      const isRegistered = !!SymbolRegistry.getIdentifier(s);\n      return isRegistered;\n    }\n    return false;\n  },\n  s => {\n    const identifier = SymbolRegistry.getIdentifier(s);\n    return ['symbol', identifier!];\n  },\n  v => v.description,\n  (_, a) => {\n    const value = SymbolRegistry.getValue(a[1]);\n    if (!value) {\n      throw new Error('Trying to deserialize unknown symbol');\n    }\n    return value;\n  }\n);\n\nconst constructorToName = [\n  Int8Array,\n  Uint8Array,\n  Int16Array,\n  Uint16Array,\n  Int32Array,\n  Uint32Array,\n  Float32Array,\n  Float64Array,\n  Uint8ClampedArray,\n].reduce<Record<string, TypedArrayConstructor>>((obj, ctor) => {\n  obj[ctor.name] = ctor;\n  return obj;\n}, {});\n\nconst typedArrayRule = compositeTransformation(\n  isTypedArray,\n  v => ['typed-array', v.constructor.name],\n  v => [...v],\n  (v, a) => {\n    const ctor = constructorToName[a[1]];\n\n    if (!ctor) {\n      throw new Error('Trying to deserialize unknown typed array');\n    }\n\n    return new ctor(v);\n  }\n);\n\nexport function isInstanceOfRegisteredClass(\n  potentialClass: any\n): potentialClass is any {\n  if (potentialClass?.constructor) {\n    const isRegistered = !!ClassRegistry.getIdentifier(\n      potentialClass.constructor\n    );\n    return isRegistered;\n  }\n  return false;\n}\n\nconst classRule = compositeTransformation(\n  isInstanceOfRegisteredClass,\n  clazz => {\n    const identifier = ClassRegistry.getIdentifier(clazz.constructor);\n    return ['class', identifier!];\n  },\n  clazz => {\n    const allowedProps = ClassRegistry.getAllowedProps(clazz.constructor);\n    if (!allowedProps) {\n      return { ...clazz };\n    }\n\n    const result: any = {};\n    allowedProps.forEach(prop => {\n      result[prop] = clazz[prop];\n    });\n    return result;\n  },\n  (v, a) => {\n    const clazz = ClassRegistry.getValue(a[1]);\n\n    if (!clazz) {\n      throw new Error(\n        'Trying to deserialize unknown class - check https://github.com/blitz-js/superjson/issues/116#issuecomment-773996564'\n      );\n    }\n\n    return Object.assign(Object.create(clazz.prototype), v);\n  }\n);\n\nconst customRule = compositeTransformation(\n  (value): value is any => {\n    return !!CustomTransformerRegistry.findApplicable(value);\n  },\n  value => {\n    const transformer = CustomTransformerRegistry.findApplicable(value)!;\n    return ['custom', transformer.name];\n  },\n  value => {\n    const transformer = CustomTransformerRegistry.findApplicable(value)!;\n    return transformer.serialize(value);\n  },\n  (v, a) => {\n    const transformer = CustomTransformerRegistry.findByName(a[1]);\n    if (!transformer) {\n      throw new Error('Trying to deserialize unknown custom value');\n    }\n    return transformer.deserialize(v);\n  }\n);\n\nconst compositeRules = [classRule, symbolRule, customRule, typedArrayRule];\n\nexport const transformValue = (\n  value: any\n): { value: any; type: TypeAnnotation } | undefined => {\n  const applicableCompositeRule = findArr(compositeRules, rule =>\n    rule.isApplicable(value)\n  );\n  if (applicableCompositeRule) {\n    return {\n      value: applicableCompositeRule.transform(value as never),\n      type: applicableCompositeRule.annotation(value),\n    };\n  }\n\n  const applicableSimpleRule = findArr(simpleRules, rule =>\n    rule.isApplicable(value)\n  );\n\n  if (applicableSimpleRule) {\n    return {\n      value: applicableSimpleRule.transform(value as never),\n      type: applicableSimpleRule.annotation,\n    };\n  }\n\n  return undefined;\n};\n\nconst simpleRulesByAnnotation: Record<string, typeof simpleRules[0]> = {};\nsimpleRules.forEach(rule => {\n  simpleRulesByAnnotation[rule.annotation] = rule;\n});\n\nexport const untransformValue = (json: any, type: TypeAnnotation) => {\n  if (isArray(type)) {\n    switch (type[0]) {\n      case 'symbol':\n        return symbolRule.untransform(json, type);\n      case 'class':\n        return classRule.untransform(json, type);\n      case 'custom':\n        return customRule.untransform(json, type);\n      case 'typed-array':\n        return typedArrayRule.untransform(json, type);\n      default:\n        throw new Error('Unknown transformation: ' + type);\n    }\n  } else {\n    const transformation = simpleRulesByAnnotation[type];\n    if (!transformation) {\n      throw new Error('Unknown transformation: ' + type);\n    }\n\n    return transformation.untransform(json as never);\n  }\n};\n"]},"metadata":{},"sourceType":"module"}