{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n\n  return to;\n};\n\nimport { isArray, isEmptyObject, isMap, isPlainObject, isPrimitive, isSet } from './is';\nimport { escapeKey, stringifyPath } from './pathstringifier';\nimport { isInstanceOfRegisteredClass, transformValue, untransformValue } from './transformer';\nimport { includes, forEach } from './util';\nimport { parsePath } from './pathstringifier';\nimport { getDeep, setDeep } from './accessDeep';\n\nfunction traverse(tree, walker, origin) {\n  if (origin === void 0) {\n    origin = [];\n  }\n\n  if (!tree) {\n    return;\n  }\n\n  if (!isArray(tree)) {\n    forEach(tree, function (subtree, key) {\n      return traverse(subtree, walker, __spreadArray(__spreadArray([], __read(origin)), __read(parsePath(key))));\n    });\n    return;\n  }\n\n  var _a = __read(tree, 2),\n      nodeValue = _a[0],\n      children = _a[1];\n\n  if (children) {\n    forEach(children, function (child, key) {\n      traverse(child, walker, __spreadArray(__spreadArray([], __read(origin)), __read(parsePath(key))));\n    });\n  }\n\n  walker(nodeValue, origin);\n}\n\nexport function applyValueAnnotations(plain, annotations) {\n  traverse(annotations, function (type, path) {\n    plain = setDeep(plain, path, function (v) {\n      return untransformValue(v, type);\n    });\n  });\n  return plain;\n}\nexport function applyReferentialEqualityAnnotations(plain, annotations) {\n  function apply(identicalPaths, path) {\n    var object = getDeep(plain, parsePath(path));\n    identicalPaths.map(parsePath).forEach(function (identicalObjectPath) {\n      plain = setDeep(plain, identicalObjectPath, function () {\n        return object;\n      });\n    });\n  }\n\n  if (isArray(annotations)) {\n    var _a = __read(annotations, 2),\n        root = _a[0],\n        other = _a[1];\n\n    root.forEach(function (identicalPath) {\n      plain = setDeep(plain, parsePath(identicalPath), function () {\n        return plain;\n      });\n    });\n\n    if (other) {\n      forEach(other, apply);\n    }\n  } else {\n    forEach(annotations, apply);\n  }\n\n  return plain;\n}\n\nvar isDeep = function (object) {\n  return isPlainObject(object) || isArray(object) || isMap(object) || isSet(object) || isInstanceOfRegisteredClass(object);\n};\n\nfunction addIdentity(object, path, identities) {\n  var existingSet = identities.get(object);\n\n  if (existingSet) {\n    existingSet.push(path);\n  } else {\n    identities.set(object, [path]);\n  }\n}\n\nexport function generateReferentialEqualityAnnotations(identitites) {\n  var result = {};\n  var rootEqualityPaths = undefined;\n  identitites.forEach(function (paths) {\n    if (paths.length <= 1) {\n      return;\n    }\n\n    var _a = __read(paths.map(function (path) {\n      return path.map(String);\n    }).sort(function (a, b) {\n      return a.length - b.length;\n    })),\n        shortestPath = _a[0],\n        identicalPaths = _a.slice(1);\n\n    if (shortestPath.length === 0) {\n      rootEqualityPaths = identicalPaths.map(stringifyPath);\n    } else {\n      result[stringifyPath(shortestPath)] = identicalPaths.map(stringifyPath);\n    }\n  });\n\n  if (rootEqualityPaths) {\n    if (isEmptyObject(result)) {\n      return [rootEqualityPaths];\n    } else {\n      return [rootEqualityPaths, result];\n    }\n  } else {\n    return isEmptyObject(result) ? undefined : result;\n  }\n}\nexport var walker = function (object, identities, path, objectsInThisPath) {\n  var _a;\n\n  if (path === void 0) {\n    path = [];\n  }\n\n  if (objectsInThisPath === void 0) {\n    objectsInThisPath = [];\n  }\n\n  if (!isPrimitive(object)) {\n    addIdentity(object, path, identities);\n  }\n\n  if (!isDeep(object)) {\n    var transformed_1 = transformValue(object);\n\n    if (transformed_1) {\n      return {\n        transformedValue: transformed_1.value,\n        annotations: [transformed_1.type]\n      };\n    } else {\n      return {\n        transformedValue: object\n      };\n    }\n  }\n\n  if (includes(objectsInThisPath, object)) {\n    return {\n      transformedValue: null\n    };\n  }\n\n  var transformationResult = transformValue(object);\n  var transformed = (_a = transformationResult === null || transformationResult === void 0 ? void 0 : transformationResult.value) !== null && _a !== void 0 ? _a : object;\n\n  if (!isPrimitive(object)) {\n    objectsInThisPath = __spreadArray(__spreadArray([], __read(objectsInThisPath)), [object]);\n  }\n\n  var transformedValue = isArray(transformed) ? [] : {};\n  var innerAnnotations = {};\n  forEach(transformed, function (value, index) {\n    var recursiveResult = walker(value, identities, __spreadArray(__spreadArray([], __read(path)), [index]), objectsInThisPath);\n    transformedValue[index] = recursiveResult.transformedValue;\n\n    if (isArray(recursiveResult.annotations)) {\n      innerAnnotations[index] = recursiveResult.annotations;\n    } else if (isPlainObject(recursiveResult.annotations)) {\n      forEach(recursiveResult.annotations, function (tree, key) {\n        innerAnnotations[escapeKey(index) + '.' + key] = tree;\n      });\n    }\n  });\n\n  if (isEmptyObject(innerAnnotations)) {\n    return {\n      transformedValue: transformedValue,\n      annotations: !!transformationResult ? [transformationResult.type] : undefined\n    };\n  } else {\n    return {\n      transformedValue: transformedValue,\n      annotations: !!transformationResult ? [transformationResult.type, innerAnnotations] : innerAnnotations\n    };\n  }\n};","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SACEA,OADF,EAEEC,aAFF,EAGEC,KAHF,EAIEC,aAJF,EAKEC,WALF,EAMEC,KANF,QAOO,MAPP;AAQA,SAASC,SAAT,EAAoBC,aAApB,QAAyC,mBAAzC;AACA,SACEC,2BADF,EAEEC,cAFF,EAIEC,gBAJF,QAKO,eALP;AAMA,SAASC,QAAT,EAAmBC,OAAnB,QAAkC,QAAlC;AACA,SAASC,SAAT,QAA0B,mBAA1B;AACA,SAASC,OAAT,EAAkBC,OAAlB,QAAiC,cAAjC;;AAQA,SAASC,QAAT,CACEC,IADF,EAEEC,MAFF,EAGEC,MAHF,EAGuB;EAArB;IAAAA;EAAqB;;EAErB,IAAI,CAACF,IAAL,EAAW;IACT;EACD;;EAED,IAAI,CAACjB,OAAO,CAACiB,IAAD,CAAZ,EAAoB;IAClBL,OAAO,CAACK,IAAD,EAAO,UAACG,OAAD,EAAUC,GAAV,EAAa;MACzB,eAAQ,CAACD,OAAD,EAAUF,MAAV,EAAgBI,uCAAMH,MAAN,IAAYI,OAAKV,SAAS,CAACQ,GAAD,CAAd,CAAZ,CAAhB,CAAR;IAAyD,CADpD,CAAP;IAGA;EACD;;EAEK,gBAAwBJ,IAAxB,EAA4B,CAA5B;EAAA,IAACO,SAAS,QAAV;EAAA,IAAYC,QAAQ,QAApB;;EACN,IAAIA,QAAJ,EAAc;IACZb,OAAO,CAACa,QAAD,EAAW,UAACC,KAAD,EAAQL,GAAR,EAAW;MAC3BL,QAAQ,CAACU,KAAD,EAAQR,MAAR,EAAcI,uCAAMH,MAAN,IAAYI,OAAKV,SAAS,CAACQ,GAAD,CAAd,CAAZ,CAAd,CAAR;IACD,CAFM,CAAP;EAGD;;EAEDH,MAAM,CAACM,SAAD,EAAYL,MAAZ,CAAN;AACD;;AAED,OAAM,SAAUQ,qBAAV,CACJC,KADI,EAEJC,WAFI,EAEsC;EAE1Cb,QAAQ,CAACa,WAAD,EAAc,UAACC,IAAD,EAAOC,IAAP,EAAW;IAC/BH,KAAK,GAAGb,OAAO,CAACa,KAAD,EAAQG,IAAR,EAAc,aAAC;MAAI,uBAAgB,CAACC,CAAD,EAAIF,IAAJ,CAAhB;IAAyB,CAA5C,CAAf;EACD,CAFO,CAAR;EAIA,OAAOF,KAAP;AACD;AAED,OAAM,SAAUK,mCAAV,CACJL,KADI,EAEJC,WAFI,EAEuC;EAE3C,SAASK,KAAT,CAAeC,cAAf,EAAyCJ,IAAzC,EAAqD;IACnD,IAAMK,MAAM,GAAGtB,OAAO,CAACc,KAAD,EAAQf,SAAS,CAACkB,IAAD,CAAjB,CAAtB;IAEAI,cAAc,CAACE,GAAf,CAAmBxB,SAAnB,EAA8BD,OAA9B,CAAsC,+BAAmB;MACvDgB,KAAK,GAAGb,OAAO,CAACa,KAAD,EAAQU,mBAAR,EAA6B;QAAM;MAAM,CAAzC,CAAf;IACD,CAFD;EAGD;;EAED,IAAItC,OAAO,CAAC6B,WAAD,CAAX,EAA0B;IAClB,gBAAgBA,WAAhB,EAA2B,CAA3B;IAAA,IAACU,IAAI,QAAL;IAAA,IAAOC,KAAK,QAAZ;;IACND,IAAI,CAAC3B,OAAL,CAAa,yBAAa;MACxBgB,KAAK,GAAGb,OAAO,CAACa,KAAD,EAAQf,SAAS,CAAC4B,aAAD,CAAjB,EAAkC;QAAM;MAAK,CAA7C,CAAf;IACD,CAFD;;IAIA,IAAID,KAAJ,EAAW;MACT5B,OAAO,CAAC4B,KAAD,EAAQN,KAAR,CAAP;IACD;EACF,CATD,MASO;IACLtB,OAAO,CAACiB,WAAD,EAAcK,KAAd,CAAP;EACD;;EAED,OAAON,KAAP;AACD;;AAED,IAAMc,MAAM,GAAG,UAACN,MAAD,EAAY;EACzB,oBAAa,CAACA,MAAD,CAAb,IACApC,OAAO,CAACoC,MAAD,CADP,IAEAlC,KAAK,CAACkC,MAAD,CAFL,IAGA/B,KAAK,CAAC+B,MAAD,CAHL,IAIA5B,2BAA2B,CAAC4B,MAAD,CAJ3B;AAImC,CALrC;;AAOA,SAASO,WAAT,CAAqBP,MAArB,EAAkCL,IAAlC,EAA+Ca,UAA/C,EAA4E;EAC1E,IAAMC,WAAW,GAAGD,UAAU,CAACE,GAAX,CAAeV,MAAf,CAApB;;EAEA,IAAIS,WAAJ,EAAiB;IACfA,WAAW,CAACE,IAAZ,CAAiBhB,IAAjB;EACD,CAFD,MAEO;IACLa,UAAU,CAACI,GAAX,CAAeZ,MAAf,EAAuB,CAACL,IAAD,CAAvB;EACD;AACF;;AAYD,OAAM,SAAUkB,sCAAV,CACJC,WADI,EAC0B;EAE9B,IAAMC,MAAM,GAA6B,EAAzC;EACA,IAAIC,iBAAiB,GAAyBC,SAA9C;EAEAH,WAAW,CAACtC,OAAZ,CAAoB,iBAAK;IACvB,IAAI0C,KAAK,CAACC,MAAN,IAAgB,CAApB,EAAuB;MACrB;IACD;;IAEK,gBAAoCD,KAAK,CAC5CjB,GADuC,CACnC,gBAAI;MAAI,WAAI,CAACA,GAAL,CAASmB,MAAT;IAAgB,CADW,EAEvCC,IAFuC,CAElC,UAACC,CAAD,EAAIC,CAAJ,EAAK;MAAK,QAAC,CAACJ,MAAF,GAAWI,CAAC,CAACJ,MAAb;IAAmB,CAFK,CAApC;IAAA,IAACK,YAAY,QAAb;IAAA,IAAkBzB,cAAc,cAAhC;;IAIN,IAAIyB,YAAY,CAACL,MAAb,KAAwB,CAA5B,EAA+B;MAC7BH,iBAAiB,GAAGjB,cAAc,CAACE,GAAf,CAAmB9B,aAAnB,CAApB;IACD,CAFD,MAEO;MACL4C,MAAM,CAAC5C,aAAa,CAACqD,YAAD,CAAd,CAAN,GAAsCzB,cAAc,CAACE,GAAf,CAAmB9B,aAAnB,CAAtC;IACD;EACF,CAdD;;EAgBA,IAAI6C,iBAAJ,EAAuB;IACrB,IAAInD,aAAa,CAACkD,MAAD,CAAjB,EAA2B;MACzB,OAAO,CAACC,iBAAD,CAAP;IACD,CAFD,MAEO;MACL,OAAO,CAACA,iBAAD,EAAoBD,MAApB,CAAP;IACD;EACF,CAND,MAMO;IACL,OAAOlD,aAAa,CAACkD,MAAD,CAAb,GAAwBE,SAAxB,GAAoCF,MAA3C;EACD;AACF;AAED,OAAO,IAAMjC,MAAM,GAAG,UACpBkB,MADoB,EAEpBQ,UAFoB,EAGpBb,IAHoB,EAIpB8B,iBAJoB,EAIS;;;EAD7B;IAAA9B;EAAgB;;EAChB;IAAA8B;EAA6B;;EAE7B,IAAI,CAACzD,WAAW,CAACgC,MAAD,CAAhB,EAA0B;IACxBO,WAAW,CAACP,MAAD,EAASL,IAAT,EAAea,UAAf,CAAX;EACD;;EAED,IAAI,CAACF,MAAM,CAACN,MAAD,CAAX,EAAqB;IACnB,IAAM0B,aAAW,GAAGrD,cAAc,CAAC2B,MAAD,CAAlC;;IACA,IAAI0B,aAAJ,EAAiB;MACf,OAAO;QACLC,gBAAgB,EAAED,aAAW,CAACE,KADzB;QAELnC,WAAW,EAAE,CAACiC,aAAW,CAAChC,IAAb;MAFR,CAAP;IAID,CALD,MAKO;MACL,OAAO;QACLiC,gBAAgB,EAAE3B;MADb,CAAP;IAGD;EACF;;EAED,IAAIzB,QAAQ,CAACkD,iBAAD,EAAoBzB,MAApB,CAAZ,EAAyC;IACvC,OAAO;MACL2B,gBAAgB,EAAE;IADb,CAAP;EAGD;;EAED,IAAME,oBAAoB,GAAGxD,cAAc,CAAC2B,MAAD,CAA3C;EACA,IAAM8B,WAAW,GAAG,0BAAoB,SAApB,wBAAoB,WAApB,GAAoB,MAApB,uBAAoB,CAAEF,KAAtB,MAA2B,IAA3B,IAA2BG,aAA3B,GAA2BA,EAA3B,GAA+B/B,MAAnD;;EAEA,IAAI,CAAChC,WAAW,CAACgC,MAAD,CAAhB,EAA0B;IACxByB,iBAAiB,0CAAOA,iBAAP,IAAwB,CAAEzB,MAAF,CAAxB,CAAjB;EACD;;EAED,IAAM2B,gBAAgB,GAAQ/D,OAAO,CAACkE,WAAD,CAAP,GAAuB,EAAvB,GAA4B,EAA1D;EACA,IAAME,gBAAgB,GAAyC,EAA/D;EAEAxD,OAAO,CAACsD,WAAD,EAAc,UAACF,KAAD,EAAQK,KAAR,EAAa;IAChC,IAAMC,eAAe,GAAGpD,MAAM,CAC5B8C,KAD4B,EAE5BpB,UAF4B,EAElBtB,uCACNS,IADM,IACF,CAAEsC,KAAF,CADE,CAFkB,EAI5BR,iBAJ4B,CAA9B;IAOAE,gBAAgB,CAACM,KAAD,CAAhB,GAA0BC,eAAe,CAACP,gBAA1C;;IAEA,IAAI/D,OAAO,CAACsE,eAAe,CAACzC,WAAjB,CAAX,EAA0C;MACxCuC,gBAAgB,CAACC,KAAD,CAAhB,GAA0BC,eAAe,CAACzC,WAA1C;IACD,CAFD,MAEO,IAAI1B,aAAa,CAACmE,eAAe,CAACzC,WAAjB,CAAjB,EAAgD;MACrDjB,OAAO,CAAC0D,eAAe,CAACzC,WAAjB,EAA8B,UAACZ,IAAD,EAAOI,GAAP,EAAU;QAC7C+C,gBAAgB,CAAC9D,SAAS,CAAC+D,KAAD,CAAT,GAAmB,GAAnB,GAAyBhD,GAA1B,CAAhB,GAAiDJ,IAAjD;MACD,CAFM,CAAP;IAGD;EACF,CAjBM,CAAP;;EAmBA,IAAIhB,aAAa,CAACmE,gBAAD,CAAjB,EAAqC;IACnC,OAAO;MACLL,gBAAgB,kBADX;MAELlC,WAAW,EAAE,CAAC,CAACoC,oBAAF,GACT,CAACA,oBAAoB,CAACnC,IAAtB,CADS,GAETuB;IAJC,CAAP;EAMD,CAPD,MAOO;IACL,OAAO;MACLU,gBAAgB,kBADX;MAELlC,WAAW,EAAE,CAAC,CAACoC,oBAAF,GACT,CAACA,oBAAoB,CAACnC,IAAtB,EAA4BsC,gBAA5B,CADS,GAETA;IAJC,CAAP;EAMD;AACF,CA1EM","names":["isArray","isEmptyObject","isMap","isPlainObject","isPrimitive","isSet","escapeKey","stringifyPath","isInstanceOfRegisteredClass","transformValue","untransformValue","includes","forEach","parsePath","getDeep","setDeep","traverse","tree","walker","origin","subtree","key","__spreadArray","__read","nodeValue","children","child","applyValueAnnotations","plain","annotations","type","path","v","applyReferentialEqualityAnnotations","apply","identicalPaths","object","map","identicalObjectPath","root","other","identicalPath","isDeep","addIdentity","identities","existingSet","get","push","set","generateReferentialEqualityAnnotations","identitites","result","rootEqualityPaths","undefined","paths","length","String","sort","a","b","shortestPath","objectsInThisPath","transformed_1","transformedValue","value","transformationResult","transformed","_a","innerAnnotations","index","recursiveResult"],"sources":["/home/julien/Bureau/P7 Front/OCR-P7-Front/node_modules/superjson/src/plainer.ts"],"sourcesContent":["import {\n  isArray,\n  isEmptyObject,\n  isMap,\n  isPlainObject,\n  isPrimitive,\n  isSet,\n} from './is';\nimport { escapeKey, stringifyPath } from './pathstringifier';\nimport {\n  isInstanceOfRegisteredClass,\n  transformValue,\n  TypeAnnotation,\n  untransformValue,\n} from './transformer';\nimport { includes, forEach } from './util';\nimport { parsePath } from './pathstringifier';\nimport { getDeep, setDeep } from './accessDeep';\n\ntype Tree<T> = InnerNode<T> | Leaf<T>;\ntype Leaf<T> = [T];\ntype InnerNode<T> = [T, Record<string, Tree<T>>];\n\nexport type MinimisedTree<T> = Tree<T> | Record<string, Tree<T>> | undefined;\n\nfunction traverse<T>(\n  tree: MinimisedTree<T>,\n  walker: (v: T, path: string[]) => void,\n  origin: string[] = []\n): void {\n  if (!tree) {\n    return;\n  }\n\n  if (!isArray(tree)) {\n    forEach(tree, (subtree, key) =>\n      traverse(subtree, walker, [...origin, ...parsePath(key)])\n    );\n    return;\n  }\n\n  const [nodeValue, children] = tree;\n  if (children) {\n    forEach(children, (child, key) => {\n      traverse(child, walker, [...origin, ...parsePath(key)]);\n    });\n  }\n\n  walker(nodeValue, origin);\n}\n\nexport function applyValueAnnotations(\n  plain: any,\n  annotations: MinimisedTree<TypeAnnotation>\n) {\n  traverse(annotations, (type, path) => {\n    plain = setDeep(plain, path, v => untransformValue(v, type));\n  });\n\n  return plain;\n}\n\nexport function applyReferentialEqualityAnnotations(\n  plain: any,\n  annotations: ReferentialEqualityAnnotations\n) {\n  function apply(identicalPaths: string[], path: string) {\n    const object = getDeep(plain, parsePath(path));\n\n    identicalPaths.map(parsePath).forEach(identicalObjectPath => {\n      plain = setDeep(plain, identicalObjectPath, () => object);\n    });\n  }\n\n  if (isArray(annotations)) {\n    const [root, other] = annotations;\n    root.forEach(identicalPath => {\n      plain = setDeep(plain, parsePath(identicalPath), () => plain);\n    });\n\n    if (other) {\n      forEach(other, apply);\n    }\n  } else {\n    forEach(annotations, apply);\n  }\n\n  return plain;\n}\n\nconst isDeep = (object: any): boolean =>\n  isPlainObject(object) ||\n  isArray(object) ||\n  isMap(object) ||\n  isSet(object) ||\n  isInstanceOfRegisteredClass(object);\n\nfunction addIdentity(object: any, path: any[], identities: Map<any, any[][]>) {\n  const existingSet = identities.get(object);\n\n  if (existingSet) {\n    existingSet.push(path);\n  } else {\n    identities.set(object, [path]);\n  }\n}\n\ninterface Result {\n  transformedValue: any;\n  annotations?: MinimisedTree<TypeAnnotation>;\n}\n\nexport type ReferentialEqualityAnnotations =\n  | Record<string, string[]>\n  | [string[]]\n  | [string[], Record<string, string[]>];\n\nexport function generateReferentialEqualityAnnotations(\n  identitites: Map<any, any[][]>\n): ReferentialEqualityAnnotations | undefined {\n  const result: Record<string, string[]> = {};\n  let rootEqualityPaths: string[] | undefined = undefined;\n\n  identitites.forEach(paths => {\n    if (paths.length <= 1) {\n      return;\n    }\n\n    const [shortestPath, ...identicalPaths] = paths\n      .map(path => path.map(String))\n      .sort((a, b) => a.length - b.length);\n\n    if (shortestPath.length === 0) {\n      rootEqualityPaths = identicalPaths.map(stringifyPath);\n    } else {\n      result[stringifyPath(shortestPath)] = identicalPaths.map(stringifyPath);\n    }\n  });\n\n  if (rootEqualityPaths) {\n    if (isEmptyObject(result)) {\n      return [rootEqualityPaths];\n    } else {\n      return [rootEqualityPaths, result];\n    }\n  } else {\n    return isEmptyObject(result) ? undefined : result;\n  }\n}\n\nexport const walker = (\n  object: any,\n  identities: Map<any, any[][]>,\n  path: any[] = [],\n  objectsInThisPath: any[] = []\n): Result => {\n  if (!isPrimitive(object)) {\n    addIdentity(object, path, identities);\n  }\n\n  if (!isDeep(object)) {\n    const transformed = transformValue(object);\n    if (transformed) {\n      return {\n        transformedValue: transformed.value,\n        annotations: [transformed.type],\n      };\n    } else {\n      return {\n        transformedValue: object,\n      };\n    }\n  }\n\n  if (includes(objectsInThisPath, object)) {\n    return {\n      transformedValue: null,\n    };\n  }\n\n  const transformationResult = transformValue(object);\n  const transformed = transformationResult?.value ?? object;\n\n  if (!isPrimitive(object)) {\n    objectsInThisPath = [...objectsInThisPath, object];\n  }\n\n  const transformedValue: any = isArray(transformed) ? [] : {};\n  const innerAnnotations: Record<string, Tree<TypeAnnotation>> = {};\n\n  forEach(transformed, (value, index) => {\n    const recursiveResult = walker(\n      value,\n      identities,\n      [...path, index],\n      objectsInThisPath\n    );\n\n    transformedValue[index] = recursiveResult.transformedValue;\n\n    if (isArray(recursiveResult.annotations)) {\n      innerAnnotations[index] = recursiveResult.annotations;\n    } else if (isPlainObject(recursiveResult.annotations)) {\n      forEach(recursiveResult.annotations, (tree, key) => {\n        innerAnnotations[escapeKey(index) + '.' + key] = tree;\n      });\n    }\n  });\n\n  if (isEmptyObject(innerAnnotations)) {\n    return {\n      transformedValue,\n      annotations: !!transformationResult\n        ? [transformationResult.type]\n        : undefined,\n    };\n  } else {\n    return {\n      transformedValue,\n      annotations: !!transformationResult\n        ? [transformationResult.type, innerAnnotations]\n        : innerAnnotations,\n    };\n  }\n};\n"]},"metadata":{},"sourceType":"module"}